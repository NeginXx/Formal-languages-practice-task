### Условие
Даны α и буква x. Найти максимальное k, такое что в L есть слова, начинающиеся с x^k
### Входные данные
На вход даётся регулярное выражение в обратной польской записи и буква x, в конце, через пробел. Пример: ab + c.aba. ∗ .bac. + . + ∗ a
Выход: 2
### Алгоритм решения
По обратной польской записи строим AST регулярного выражения. Определим функцию func, принимающая вершину поддерева в качестве аргумента и возвращающая два числа x1 и x2. x1 - максимальное k, что в поддереве есть слово с префиксом x^k. x2 - максимальное k, что в поддереве есть слово, равное x^k. x1 и x2 натуральные числа, для некоторых поддеревьев эти значения могут быть неопределены (т.к. по факту бесконечность), но в этом случае алгоритм можно будет тут же завершать, выдавая ответ, подробности позже. func от поддерева из одной вершины (ясно, что это вершина с какой-то буквой алфавита) возвращает x1=1 и x2=1, если буква в этой вершине x, 0 0 в противном случае. Пусть теперь func запускается от вершины с +, тогда x1 равен max(left.x1, right.x1) и x2 равен max(left.x2, right.x2), где left.x1 это значение x1, которое вернёт рекурсивно запущенная от левого поддерева func, left.x2 и right определяются аналогично. Полученные x1 и x2 вычислены верно - тривиально. Если func запускается от вершины с .(конкатенация), x1 = max(left.x1, left.x2 + right.x1), x2 = left.x2 + right.x2. Доказательство: слово с наибольшим префиксом либо совпадает со словом, соответствующим left.x1, либо было получено, как слово, полностью состоящее из букв x, сконкатенированное со словом с наибольшим префиксом из букв x из правого поддерева. Отсюда и такая формула на x1. Формула для x2 тривиальна. Если func запускается от звезды Клини и её аргумент, поддерево, имеет значение x2 больше нуля, ясно, что ответ k = inf, завершаем рекурсивный обход, ответ найден. Если x2 = 0, то x1 совпадает с x1 от поддерева. В конце рекурсивного обхода дерева в качестве ответа выводим root.x1, ведь x1 обозначает в точности то, что просит условие задачи
